<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' 'unsafe-inline' https://www.gstatic.com https://cdn.jsdelivr.net https://firebaseinstallations.googleapis.com https://fcmregistrations.googleapis.com; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https://www.gstatic.com https://firebaseinstallations.googleapis.com https://fcmregistrations.googleapis.com https://fcm.googleapis.com; font-src 'self' data:;">
  <title>Admin - Produtos</title>
  <style>
    /* Estilos Gerais */
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    
    .container {
      max-width: 900px;
      margin: auto;
      background: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      margin-top: 20px;
    }
    
    h1, h2 {
      text-align: center;
      color: #333;
    }

    /* Estilização do Formulário */
    form {
      background: #fafafa;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
      margin-bottom: 30px;
    }
    
    label {
      display: block;
      margin: 10px 0 5px;
      font-weight: bold;
      color: #333;
    }
    
    input, textarea, select {
      width: 100%;
      padding: 10px;
      margin-top: 5px;
      border: 1px solid #ccc;
      border-radius: 5px;
      font-size: 16px;
    }

    /* Estilo específico para o input de arquivo */
    input[type="file"] {
      padding: 3px;
    }

    button {
      display: block;
      width: 100%;
      padding: 10px;
      background: #007BFF;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
      transition: background 0.3s ease-in-out;
    }

    button:hover {
      background: #0056b3;
    }

    /* Grid de Produtos */
    .product-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }

    .product-card {
      width: 250px;
      background: #ffffff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      text-align: center;
      padding: 15px;
      position: relative;
      transition: transform 0.2s ease-in-out;
    }

    .product-card:hover {
      transform: scale(1.03);
    }

    .product-card img {
      max-width: 100%;
      max-height: 120px;
      border-radius: 5px;
    }

    .delete-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: red;
      color: white;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      cursor: pointer;
      font-weight: bold;
    }

    /* Estilos do Filtro de Histórico */
    #historySearch {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: space-between;
      align-items: center;
      background: #fafafa;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 1px 5px rgba(0, 0, 0, 0.1);
      margin-top: 30px;
    }

    #historySearch input, #historySearch select {
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ccc;
      background: #fff;
      width: 100%;
    }

    /* Botões dentro da área de filtros */
    #searchButton {
      width: 100%;
      padding: 10px;
      background: #007BFF;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      margin-top: 10px;
      transition: background 0.3s ease-in-out;
    }

    #searchButton:hover {
      background: #0056b3;
    }

    /* Estilização da Tabela */
    #historyResults table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      background: #fff;
      border-radius: 8px;
      overflow: hidden;
    }

    #historyResults th, #historyResults td {
      padding: 12px;
      border: 1px solid #ddd;
      text-align: left;
    }

    #historyResults th {
      background: #007BFF;
      color: white;
      font-weight: bold;
    }

    #historyResults tr:nth-child(even) {
      background: #f9f9f9;
    }

    #historyResults tr:hover {
      background: #f1f1f1;
    }

    /* Responsividade */
    @media (max-width: 768px) {
      .product-grid {
        flex-direction: column;
        align-items: center;
      }
      .product-card {
        width: 90%;
      }
      #historySearch {
        flex-direction: column;
        gap: 10px;
      }
      #historySearch input, #historySearch select, #historySearch button {
        width: 100%;
      }
    }

    /* NOVO: Estilos para Toast Notifications */
    .toast {
      position: fixed;
      top: 20px;
      right: 20px;
      background: #333;
      color: #fff;
      padding: 15px 20px;
      border-radius: 5px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      max-width: 90%;
      word-wrap: break-word;
    }
    .toast.show {
      opacity: 1;
    }
    .toast.success {
      background: #4CAF50;
    }
    .toast.error {
      background: #f44336;
    }
    .toast.warning {
      background: #ff9800;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Admin - Gerenciar Produtos</h1>
    <a href="/logout" style="display: block; text-align: center; margin-bottom: 20px;">Sair!</a>
    <form id="productForm">
      <label for="title">Título:</label>
      <input type="text" id="title" required>
      
      <label for="price">Preço (centavos):</label>
      <input type="number" id="price" required>
      
      <label for="imageFile">Imagem:</label>
      <input type="file" id="imageFile" accept="image/*" required>
      <input type="hidden" id="imageBase64">
      <label for="description">Descrição:</label>
      <textarea id="description"></textarea>
      
      <button type="submit">Adicionar Produto</button>
    </form>
    
    <h2>Produtos Existentes</h2>
    <div class="product-grid" id="productGrid"></div>

    <h2>Histórico de Compras</h2>
    <div id="historySearch">
      <input type="text" id="searchNome" placeholder="Buscar por Nome">
      <input type="text" id="searchTelefone" placeholder="Buscar por Telefone">
      <select id="mes"></select>
      <select id="ano"></select>
      <button id="searchButton">Buscar</button>
      </div>

    <div id="historyResults"></div>
  </div>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-messaging-compat.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
  <script>

    // NOVO: Função para exibir toast notifications
    function showToast(message, type = 'info') {
      const toast = document.createElement('div');
      toast.className = `toast ${type}`;
      toast.textContent = message;
      document.body.appendChild(toast);

      // Força reflow para aplicar transição
      void toast.offsetWidth;
      toast.classList.add('show');

      setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(() => {
          if (toast.parentNode) {
            document.body.removeChild(toast);
          }
        }, 300);
      }, 3000);
    }

    // NOVO: Função centralizada para fazer chamadas de API com tratamento de sessão expirada
        async function authenticatedFetch(url, options = {}) {
            try {
                const response = await fetch(url, options);

                // Se a resposta for 401 (Não Autorizado), a sessão expirou
                if (response.status === 401) {
                    const data = await response.json();
                    showToast(data.error || 'Sua sessão expirou, faça o login novamente.', 'error');
                    // Redireciona para a página de login
                    setTimeout(() => {
                      window.location.href = '/login';
                    }, 1500);
                    // Lança um erro para parar a execução do código que chamou esta função
                    throw new Error('Sessão expirada');
                }

                return response; // Se não houver erro, retorna a resposta original
            } catch (error) {
                // Se o erro já for de sessão expirada, apenas o propaga
                if (error.message === 'Sessão expirada') {
                    throw error;
                }
                // Para outros erros de rede, etc.
                if (typeof console !== 'undefined' && console.error) {
                  console.error('Erro na chamada da API:', error);
                }
                showToast('Ocorreu um erro de comunicação com o servidor.', 'error');
                throw error;
            }
        }


    // NOVO: Listener para converter a imagem selecionada para Base64
    document.getElementById('imageFile').addEventListener('change', function(event) {
        const file = event.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                // Armazena o resultado no campo oculto
                document.getElementById('imageBase64').value = e.target.result;
            };
            reader.readAsDataURL(file); // Inicia a leitura do arquivo
        }
    });

    // MODIFICADO: Envia o formulário e adiciona um novo produto
    document.getElementById('productForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const title = document.getElementById('title').value;
      const price = document.getElementById('price').value;
      // Pega o valor do campo oculto, que agora contém a imagem em Base64
      const image = document.getElementById('imageBase64').value;
      const description = document.getElementById('description').value;
      
      // Verifica se a imagem foi selecionada
      if (!image) {
        showToast('Por favor, selecione uma imagem.', 'warning');
        return;
      }

      const product = { title, price, image, description };

      try {
        const response = await authenticatedFetch('/api/products', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(product)
        });
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Erro ao adicionar produto');
        }
        showToast('Produto adicionado com sucesso!', 'success');
        document.getElementById('productForm').reset();
        document.getElementById('imageBase64').value = ''; // Limpa o campo oculto
        loadProducts();
      } catch (error) {
        // O erro de sessão expirada já é tratado dentro do authenticatedFetch,
        // então aqui só precisamos nos preocupar com outros erros.
        if (error.message !== 'Sessão expirada') {
          showToast(error.message, 'error');
        }
      }
    });
    
    // Carrega os produtos e exibe-os em cards
    // CORRIGIDO: Removido innerHTML para prevenir XSS
    async function loadProducts() {
      try {
        const response = await authenticatedFetch('/api/products');
        const products = await response.json();
        const grid = document.getElementById('productGrid');
        grid.innerHTML = '';
        products.forEach(product => {
          const card = document.createElement('div');
          card.className = 'product-card';
          card.setAttribute('data-id', product.id);

          // Botão de deletar
          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-button';
          deleteBtn.textContent = 'x';
          deleteBtn.addEventListener('click', () => deleteProduct(product.id));

          // Imagem
          const img = document.createElement('img');
          img.src = product.image;
          img.alt = product.title;
          img.onerror = function() { this.style.display = 'none'; };

          // Título
          const title = document.createElement('h3');
          title.textContent = product.title;

          // Preço
          const price = document.createElement('p');
          price.textContent = `Preço: R$${(product.price/100).toFixed(2)}`;

          // Descrição
          const desc = document.createElement('p');
          desc.textContent = product.description || '';

          // Monta o card
          card.appendChild(deleteBtn);
          card.appendChild(img);
          card.appendChild(title);
          card.appendChild(price);
          card.appendChild(desc);

          grid.appendChild(card);
        });
        // Inicializa o Sortable para reordenar os cards
        new Sortable(grid, {
          animation: 150, // Adiciona uma animação suave ao arrastar
          onEnd: function(evt) {
              // --- INÍCIO DA CORREÇÃO ---
              
              // 1. Pega todos os elementos filhos do grid na nova ordem.
              const items = grid.children;

              // 2. Cria o array 'newOrder' mapeando os itens e pegando o 'data-id' de cada um.
              const newOrder = Array.from(items).map(item => item.getAttribute('data-id'));

              // --- FIM DA CORREÇÃO ---

              // Agora a variável 'newOrder' existe e contém a lista de IDs na ordem correta.
              authenticatedFetch('/api/products/reorder', { 
                  method: 'PUT',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({ order: newOrder })
              })
              .then(response => {
                  if (!response.ok) {
                      throw new Error('Falha ao reordenar produtos.');
                  }
                  return response.json();
              })
              .then(data => console.log(data.message)) // Exibe a mensagem de sucesso
              .catch(error => {
                  if (error.message !== 'Sessão expirada') {
                      console.error('Erro ao reordenar:', error);
                      // CORREÇÃO: Usar showToast ao invés de alert
                      showToast('Ocorreu um erro ao tentar salvar a nova ordem.', 'error');
                  }
              });
          }
      });
      } catch (error) {
                if (error.message !== 'Sessão expirada') {
                    console.error('Erro ao carregar produtos:', error);
                }
            }
    }
    
    // Função para excluir um produto
    // CORRIGIDO: Substituído alert() por showToast()
    async function deleteProduct(productId) {
      if (!confirm('Tem certeza que deseja excluir este produto?')) return;
      try {
        const response = await authenticatedFetch(`/api/products/${productId}`, {
          method: 'DELETE'
        });
        if (!response.ok) {
          const errorData = await response.json();
          throw new Error(errorData.error || 'Erro ao excluir produto');
        }
        showToast('Produto excluído com sucesso!', 'success');
        loadProducts();
      } catch (error) {
        if (error.message !== 'Sessão expirada') {
          showToast(error.message, 'error');
        }
      }
    }
    
    function carregarMesAno() {
      const selectMes = document.getElementById('mes');
      const selectAno = document.getElementById('ano');
      const hoje = new Date();
      const anoAtual = hoje.getFullYear();
      const mesAtual = hoje.getMonth() + 1;

      const meses = [
        "Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho",
        "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
      ];
      selectMes.innerHTML = meses.map((m, i) => 
        `<option value="${i + 1}" ${i + 1 === mesAtual ? "selected" : ""}>${m}</option>`
      ).join("");

      selectAno.innerHTML = "";
      for (let ano = 2025; ano <= anoAtual; ano++) {
        selectAno.innerHTML += `<option value="${ano}" ${ano === anoAtual ? "selected" : ""}>${ano}</option>`;
      }
    }

    // CORRIGIDO: Removido innerHTML para prevenir XSS
    async function loadHistory() {
      const nome = document.getElementById('searchNome')?.value.trim() || "";
      const telefone = document.getElementById('searchTelefone')?.value.trim() || "";
      const mes = document.getElementById('mes').value;
      const ano = document.getElementById('ano').value;

      let url = `/api/purchase-history?mes=${mes}&ano=${ano}`;
      if (nome) url += `&nome=${encodeURIComponent(nome)}`;
      if (telefone) url += `&telefone=${encodeURIComponent(telefone)}`;

      try {
        const response = await authenticatedFetch(url);
        const history = await response.json();
        const resultsDiv = document.getElementById('historyResults');
        resultsDiv.innerHTML = '';

        if (history.length === 0) {
          const noResultsMsg = document.createElement('p');
          noResultsMsg.textContent = 'Nenhum registro encontrado.';
          resultsDiv.appendChild(noResultsMsg);
          return;
        }

        // Cria tabela com createElement
        const table = document.createElement('table');
        table.style.width = '100%';
        table.style.textAlign = 'left';
        table.setAttribute('border', '1');

        // Cabeçalho da tabela
        const thead = document.createElement('thead');
        const headerRow = document.createElement('tr');
        ['Nome', 'Telefone', 'Data/Hora', 'Status'].forEach(headerText => {
          const th = document.createElement('th');
          th.textContent = headerText;
          headerRow.appendChild(th);
        });
        thead.appendChild(headerRow);
        table.appendChild(thead);

        // Corpo da tabela
        const tbody = document.createElement('tbody');
        history.forEach(item => {
          const row = document.createElement('tr');

          const nomeCell = document.createElement('td');
          nomeCell.textContent = item.nome;
          row.appendChild(nomeCell);

          const telefoneCell = document.createElement('td');
          telefoneCell.textContent = formatPhone(item.telefone);
          row.appendChild(telefoneCell);

          const dataCell = document.createElement('td');
          dataCell.textContent = new Date(item.dataTransacao).toLocaleString('pt-BR');
          row.appendChild(dataCell);

          const statusCell = document.createElement('td');
          statusCell.textContent = item.status;
          row.appendChild(statusCell);

          tbody.appendChild(row);
        });
        table.appendChild(tbody);
        resultsDiv.appendChild(table);
      } catch (error) {
        if (error.message !== 'Sessão expirada') {
          if (typeof console !== 'undefined' && console.error) {
            console.error('Erro ao carregar histórico:', error);
          }
          showToast('Erro ao carregar histórico', 'error');
        }
      }
    }

    function formatPhone(value) {
      value = value.replace(/\D/g, "");
      if (value.length > 0) value = "(" + value;
      if (value.length > 3) value = value.slice(0, 3) + ") " + value.slice(3);
      if (value.length > 10) value = value.slice(0, 10) + "-" + value.slice(10);
      return value;
    }

    document.getElementById('searchButton').addEventListener('click', loadHistory);

    window.onload = () => {
      loadProducts();
      carregarMesAno();
      loadHistory();
    };

    

  
    // NOVO: Código para inicializar o Firebase e gerenciar notificações

    
       // NOVO: Script para registrar o Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/firebase-messaging-sw.js')
        .then(function(registration) {
          console.log('Service Worker registrado com sucesso:', registration);
        }).catch(function(error) {
          console.log('Falha ao registrar o Service Worker:', error);
        });
    }

    // CORRIGIDO: Busca configuração do Firebase do backend ao invés de hardcoded
    let messaging;

    async function initializeFirebase() {
      try {
        const response = await fetch('/api/firebase-config');
        if (!response.ok) {
          throw new Error('Erro ao buscar configuração do Firebase');
        }
        const config = await response.json();

        // Remove vapidKey do config principal
        const { vapidKey, ...firebaseConfig } = config;

        firebase.initializeApp(firebaseConfig);
        if (typeof console !== 'undefined' && console.log) {
          console.log('[Firebase JS] SDK do Firebase inicializado.');
        }

        messaging = firebase.messaging();

        // Escuta por notificações recebidas em primeiro plano
        messaging.onMessage((payload) => {
          if (typeof console !== 'undefined' && console.log) {
            console.log('[Firebase JS] MENSAGEM RECEBIDA EM PRIMEIRO PLANO: ', payload);
          }
          // Mostra toast ao invés de alert
          showToast(
            `${payload.notification.title}: ${payload.notification.body}`,
            'success'
          );
        });

        return vapidKey;
      } catch (error) {
        if (typeof console !== 'undefined' && console.error) {
          console.error('Erro ao inicializar Firebase:', error);
        }
        showToast('Erro ao inicializar notificações', 'error');
        return null;
      }
    }

    function requestNotificationPermission(vapidKey) {
      if (!vapidKey || !messaging) {
        showToast('Firebase não está configurado corretamente', 'error');
        return;
      }

      if (typeof console !== 'undefined' && console.log) {
        console.log('Solicitando permissão para notificações...');
      }

      Notification.requestPermission().then((permission) => {
        if (permission === 'granted') {
          if (typeof console !== 'undefined' && console.log) {
            console.log('Permissão para notificação concedida.');
          }

          messaging.getToken({ vapidKey: vapidKey }).then((currentToken) => {
            if (currentToken) {
              if (typeof console !== 'undefined' && console.log) {
                console.log('[Firebase JS] Token obtido:', currentToken);
              }
              sendTokenToServer(currentToken);
              showToast('Notificações ativadas com sucesso!', 'success');
            } else {
              if (typeof console !== 'undefined' && console.error) {
                console.error('[Firebase JS] Não foi possível obter o token.');
              }
              showToast('Erro ao obter token de notificação', 'error');
            }
          }).catch((err) => {
            if (typeof console !== 'undefined' && console.error) {
              console.error('[Firebase JS] Erro ao obter token:', err);
            }
            showToast('Erro ao configurar notificações', 'error');
          });

        } else {
          if (typeof console !== 'undefined' && console.warn) {
            console.warn('[Firebase JS] Permissão negada.');
          }
          showToast('Permissão para notificações negada', 'warning');
        }
      });
    }

    // Função para enviar o token para o seu backend
    // MODIFICADO: Função para enviar o token para o seu backend agora usa authenticatedFetch
    async function sendTokenToServer(token) {
      try {
        const response = await authenticatedFetch('/api/devices', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ token: token }),
        });
        const data = await response.json();
        console.log('Resposta do servidor ao registrar dispositivo:', data);
      } catch (err) {
        if (err.message !== 'Sessão expirada') {
          console.error('Erro ao enviar token para o servidor:', err);
        }
      }
    }

    // CORRIGIDO: Inicializa Firebase e configura botão de notificações
    let firebaseVapidKey = null;

    // Inicializa Firebase quando a página carregar
    initializeFirebase().then(vapidKey => {
      firebaseVapidKey = vapidKey;

      // Adiciona um botão para o admin ativar as notificações
      const notificationButton = document.createElement('button');
      notificationButton.textContent = 'Ativar Notificações de Venda';
      notificationButton.style.backgroundColor = '#28a745';
      notificationButton.style.marginTop = '20px';
      notificationButton.onclick = () => requestNotificationPermission(firebaseVapidKey);
      // Insere o botão no container principal
      document.querySelector('.container').prepend(notificationButton);
    });
    
  

  </script>
</body>
</html>